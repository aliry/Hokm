I'm building a server to Hokm card game.
The game should work like this:
It will have a website client connect to our server.
On the website a user can create a new game. We call this user the game manager.
when game manager starts a game, the server need to generate a session id for the game as well as two unique (5 digit code) for each team.
Then the game manager can give one of the team codes to their partner and the other one to the two player in the opponent team to also join the game. 
the server should not allow more than two users to join each team.
Other users can then open the website and click on join the game using their code.
Once all users join the game then manager can click on start to start the game.

Once game started:
1- the server should randomly pick a player to be hakem.
2- generate cards for hakem and wait for hakem to choose the trump suit. 
3- after that server need to distribute the reset of the card to all players.
4- after than server should implement functionalities need to play the game based on the rules of Hokm
5- server should track the score and notify players when a team wins 

Write the code for the server in typescript

==================================================
I'm implementing a service for Hokm card game.
Here is my service code:
```
import express from 'express';
import { createServer } from 'http';
import { Socket, Server as SocketIOServer } from 'socket.io';
import { GameSessionManager } from './gameSessionManager';
import { SocketHandler } from './socketHandler';

const app = express();
app.use(express.json());

const httpServer = createServer(app);
const io = new SocketIOServer(httpServer);

const gameSessions = new GameSessionManager();
const socketHandler = new SocketHandler(io, gameSessions);

// Endpoint to create a new game session
app.post('/create-game', (req, res) => {
  const managerName: string = req.body.managerName;

  if (!managerName) {
    return res.status(400).send('Manager name is required');
  }

  try {
    const session = gameSessions.createGameSession(managerName);
    res.json({
      sessionId: session.SessionId,
      teamCodes: session.TeamCodes,
      managerName
    });
  } catch (error: any) {
    console.error('Error creating game session:', error);
    res.status(400).send(error.message);
  }
});

io.on('connection', (socket: Socket) => {
  socketHandler.handleConnection(socket);
});

httpServer.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```
Here is the code for GameSessionManager class:
```
import { GameSession } from "./gameSession";

const MAX_CONCURRENT_GAMES = 100;

/**
 * Manages game sessions.
 */
export class GameSessionManager {
  private gameSessions: { [sessionId: string]: GameSession };

  constructor() {
    this.gameSessions = {};
  }

  /**
   * Creates a new game session.
   * @param managerName - The name of the game session manager.
   * @returns The created game session.
   */
  public createGameSession(managerName: string): GameSession {
    if (Object.keys(this.gameSessions).length >= MAX_CONCURRENT_GAMES) {
      throw new Error("Game server reached maximum capacity. Please try again later.");
    }

    const session = new GameSession(managerName);
    this.gameSessions[session.SessionId] = session;
    return session;
  }

  /**
   * Retrieves a game session by its session ID.
   * @param sessionId - The ID of the game session.
   * @returns The game session with the specified ID, or undefined if not found.
   */
  public getGameSession(sessionId: string): GameSession | undefined {
    return this.gameSessions[sessionId];
  }

  /**
    * Retrieves a game session by its team code.
    * @param teamCode - The team code of the game session.
    * @returns The game session with the specified team code, or undefined if not found.
    */
  public getGameSessionByTeamCode(teamCode: string): GameSession | undefined {
    const session = Object.values(this.gameSessions).find(session => session.TeamCodes.includes(teamCode));
    return session;
  }

  /**
    * Retrieves a game session by player ID.
    * @param playerId - The ID of the player.
    * @returns The game session containing the player, or undefined if not found.
    */
  public getGameSessionByPlayerId(playerId: string): GameSession | undefined {
    const session = Object.values(this.gameSessions).find(session => session.Players.some(player => player.id === playerId));
    return session;
  }

  /**
   * Retrieves all game sessions.
   * @returns An array of all game sessions.
   */
  public getAllGameSessions(): GameSession[] {
    return Object.values(this.gameSessions);
  }

  /**
   * Removes a game session by its session ID.
   * @param sessionId - The ID of the game session to remove.
   */
  public removeGameSession(sessionId: string): void {
    delete this.gameSessions[sessionId];
  }
}

```

here is the code for GameSession class:
```
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';
import { Card, Player, Round } from './types';

/**
 * Class representing a game session.
 */
export class GameSession {
  private sessionId: string;
  private teamCodes: string[];
  private players: Player[];
  private manager: Player;
  private hakem: Player | null;
  private deck: Card[];
  private currentRound: number;
  private maxRounds: number;
  private scores: { [teamCode: string]: number };
  private currentPlayerIndex: number;
  private trumpSuit: string | null;
  private gameStarted: boolean;
  private gameEnded: boolean;
  private roundHistory: Round[];

  /**
 * Creates a new game session.
 * @param {string} managerName - The name of the game manager for the game session.
 * @returns {GameSession} The newly created game session.
 */
  constructor(managerName: string) {
    this.sessionId = uuidv4(); // Generate a UUID for the session ID
    this.teamCodes = [this.generateUniqueCode(this.sessionId + 'team1'), this.generateUniqueCode(this.sessionId + 'team2')];
    this.players = [];
    this.manager = { id: "", teamCode: this.teamCodes[0], name: managerName };
    this.hakem = null;
    this.deck = [];
    this.currentRound = 0;
    this.maxRounds = 0;
    this.scores = {
      [this.teamCodes[0]]: 0,
      [this.teamCodes[1]]: 0
    };
    this.currentPlayerIndex = 0;
    this.trumpSuit = null;
    this.gameStarted = false;
    this.gameEnded = false;
    this.roundHistory = [];
  }

  /**
   * Adds a player to the game session.
   * @param {string} playerName - The name of the player.
   * @param {string} teamCode - The team code of the player.
   * @param {string} socketId - The socket ID of the player.
   * @returns {Player} The player that was added to the game session.
   * @throws {Error} If the player name is not unique or the team has reached its capacity.
   */
  public addPlayer(playerName: string, teamCode: string, socketId: string): Player {
    const isNameUnique = this.players.every(player => player.name !== playerName);
    if (!isNameUnique) {
      throw new Error('Player name must be unique.');
    }

    // First player joining should be the manager
    if (this.Players.length === 0) {
      if (
        this.Manager.name !== playerName ||
        this.Manager.teamCode !== teamCode
      ) {
        throw new Error('Game manager must join the team 1 first.');
      }
      this.Manager.id = socketId;
    }

    const teamPlayerCount = this.players.filter(player => player.teamCode === teamCode).length;
    if (teamPlayerCount >= 2) {
      throw new Error('Team has reached its capacity.');
    }

    const player: Player = { id: socketId, teamCode, name: playerName };
    this.players.push(player);

    return player;
  }

  /**
   * Get the session ID for the game session.
   * @returns {string} The session ID.
   */
  public get SessionId(): string {
    return this.sessionId;
  }

  /**
    * Get the team codes for the game session.
    * @returns {string[]} The team codes.
    */
  public get TeamCodes(): string[] {
    return this.teamCodes;
  }

  /**
  * Get the players in the game session.
  * @returns {string[]} The players.
  */
  public get Players(): Player[] {
    return this.players;
  }

  /**
  * Get the manager of the game session.
  * @returns {Player} The manager.
  */
  public get Manager(): Player {
    return this.manager;
  }

  /**
  * Get the hakem of the game session.
  * @returns {Player | null} The hakem.
  */
  public get Hakem(): Player | null {
    return this.hakem;
  }

  /**
  * Get the deck of cards in the game session.
  * @returns {Card[]} The deck of cards.
  */
  public get Deck(): Card[] {
    return this.deck;
  }

  /**
  * Get the current round number in the game session.
  * @returns {number} The current round number.
  */
  public get CurrentRound(): number {
    return this.currentRound;
  }

  /**
  * Get the maximum number of rounds in the game session.
  * @returns {number} The maximum number of rounds.
  */
  public get MaxRounds(): number {
    return this.maxRounds;
  }

  /**
  * Get the scores of the teams in the game session.
  * @returns {{ [teamCode: string]: number }} The scores of the teams.
  */
  public get Scores(): { [teamCode: string]: number } {
    return this.scores;
  }

  /**
  * Get the index of the current player in the game session.
  * @returns {number} The index of the current player.
  */
  public get CurrentPlayerIndex(): number {
    return this.currentPlayerIndex;
  }

  /**
  * Get the trump suit in the game session.
  * @returns {string | null} The trump suit.
  */
  public get TrumpSuit(): string | null {
    return this.trumpSuit;
  }

  /**
  * Check if the game session has started.
  * @returns {boolean} True if the game session has started, false otherwise.
  */
  public get GameStarted(): boolean {
    return this.gameStarted;
  }

  /**
  * Check if the game session has ended.
  * @returns {boolean} True if the game session has ended, false otherwise.
  */
  public get GameEnded(): boolean {
    return this.gameEnded;
  }

  /**
  * Get the round history in the game session.
  * @returns {Round[]} The round history.
  */
  public get RoundHistory(): Round[] {
    return this.roundHistory;
  }

  /**
   * Sets the value of the Hakem property.
   * @param {Player} hakem - The new value for the Hakem property.
   */
  public set Hakem(hakem: Player) {
    this.hakem = hakem;
  }

  /**
   * Sets the value of the Deck property.
   * @param {Card[]} deck - The new value for the Deck property.
   */
  public set Deck(deck: Card[]) {
    this.deck = deck;
  }

  /**
   * Sets the value of the TrumpSuit property.
   * @param {string | null} trumpSuit - The new value for the TrumpSuit property.
   */
  public set TrumpSuit(trumpSuit: string | null) {
    this.trumpSuit = trumpSuit;
  }

  /**
   * Generate a unique 6-digit alphanumeric code based on a UUID seed.
   * @param {string} uuidSeed - The UUID seed used to generate the code.
   * @returns {string} The generated unique code.
   */
  private generateUniqueCode(uuidSeed: string): string {
    const hash = crypto.createHash('sha256').update(uuidSeed).digest('hex');
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const length = 6;
    let code = '';

    for (let i = 0; i < length; i++) {
      // Convert a substring of the hash into a number before taking the modulo
      const hashSegment = hash.substring(i * 2, i * 2 + 2);
      const index = parseInt(hashSegment, 16) % characters.length;
      code += characters[index];
    }

    return code;
  }

  /**
   * Generates a standard deck of playing cards.
   * Shuffles a deck of cards using the Fisher-Yates algorithm.
   * @returns {Array<{ suit: string, value: string }>} The generated deck of cards.
   */
  private generateShuffledDeck(): Card[] {
    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
    const values = [
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      '10',
      'J',
      'Q',
      'K',
      'A'
    ];

    const deck: Card[] = [];
    for (const suit of suits) {
      for (const value of values) {
        deck.push({ suit, value });
      }
    }

    // Shuffle the deck using the Fisher-Yates algorithm
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }

    return deck;
  }
  // Add other game functionalities as methods here
}

```
Here is the SocketHandler class:
```
import { Player } from "./types";
import { Socket, Server as SocketIOServer } from 'socket.io';
import { GameSessionManager } from "./gameSessionManager";

export class SocketHandler {
  private io: SocketIOServer;
  private gameSessionManager: GameSessionManager;

  constructor(io: SocketIOServer, gameSessionManager: GameSessionManager) {
    this.io = io;
    this.gameSessionManager = gameSessionManager;
  }

  public handleConnection(socket: Socket): void {
    socket.on('join-game', ({ teamCode, playerName }: { teamCode: string, playerName: string }) => {
      if (typeof teamCode !== 'string' || typeof playerName !== 'string') {
        socket.emit('error', 'Invalid team code or player name');
        return;
      }

      const session = this.gameSessionManager.getGameSessionByTeamCode(teamCode);
      if (!session) {
        socket.emit('error', 'Invalid team code');
        return;
      }

      let newPlayer: Player;
      try {
        newPlayer = session.addPlayer(playerName, teamCode, socket.id);
      } catch (error: any) {
        socket.emit('error', error.message);
        return;
      }

      socket.join(session.SessionId);
      socket.emit('joined-game', {
        sessionId: session.SessionId,
        newPlayer
      });

      const allTeamsFull = session.TeamCodes.every(
        (code) =>
          session.Players.filter((player) => player.teamCode === code).length === 2
      );

      if (allTeamsFull) {
        this.io.to(session.SessionId).emit('all-players-joined', {
          team1: session.Players.filter(
            (player) => player.teamCode === session.TeamCodes[0]
          ),
          team2: session.Players.filter(
            (player) => player.teamCode === session.TeamCodes[1]
          )
        });

        session.Hakem = session.Players[Math.floor(Math.random() * 4)];

        this.io.to(session.SessionId).emit('game-started', {
          hakem: session.Hakem
        });

        // session.Deck = generateShuffledDeck();
        const hakemCards = session.Deck.splice(0, 5);
        this.io.to(session.Hakem.id).emit('hakem-cards', {
          cards: hakemCards
        });
      }
    });

    socket.on('select-trump-suit', ({ suit }: { suit: string }) => {
      const session = this.gameSessionManager.getGameSessionByPlayerId(socket.id);
      if (!session || session.Hakem?.id !== socket.id) {
        return;
      }

      session.TrumpSuit = suit;
      this.io.to(session.SessionId).emit('trump-suit-selected', {
        suit
      });
    });

    socket.on('disconnect', () => {
      const session = this.gameSessionManager.getGameSessionByPlayerId(socket.id);
      if (!session) {
        return;
      }

      const playerIndex = session.Players.findIndex(
        (player) => player.id === socket.id
      );
      const player = session.Players[playerIndex];
      session.Players.splice(playerIndex, 1);

      this.io.to(session.SessionId).emit('player-left', {
        playerName: player.name
      });
    });
  }
}
```

I want you to implement a new class called "GameRuntime" to handle all the game events such as join-game and select-trump-suit and disconnect, ....
and refactor the SocketHandler to use those event handlers instead of having the actual game logic inside the SocketHandler
Make sure write the complete code for any class need to change or added.

